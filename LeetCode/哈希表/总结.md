## 哈希表

也叫散列表

一般哈希表都是用来快速判断一个元素是否出现集合里

## 哈希函数

一种函数把把值直接映射为哈希表上的索引

## 哈希碰撞

1. 拉链法

发生冲突的元素都被存储在链表中

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

2. 线性探测法

一定要保证tableSize大于dataSize。

冲突就向下查找下一个空位放置

## 三种哈希结构

* 数组
* set （集合）
* dictionary(map)(映射)

ConcurrentHashSet：线程安全的HashSet，可以在多线程环境中使用。

ImmutableHashSet：不可修改的HashSet，可以确保集合中的元素不会被更改。

| 特性        | 底层实现           | 是否有序  | 数值是否可以重复  | 能否更改数值 | 查询效率  |     增删效率 |
| ------------- |:-------------:| -----:| -----:|-------:| -----:|---------:|
|HashSet	|哈希表	|无序	|不可重复	|  不可更改	 |O(1)	|     O(1) |
|SortedSet	|红黑树	|有序	|不可重复	|  不可更改	 |O(log n)	| O(log n) |
|ConcurrentHashSet	|哈希表	|无序	|不可重复	|  不可更改	 |O(1)	|O(1)|
|ImmutableHashSet	|哈希表	|无序	|不可重复	|  不可更改	 |O(1)	|-|

| 类型	                                 | 底层实现	      |是否有序	| key是否可以重复	 |key 能否更改数值	|查询效率	|增删效率|
|-------------------------------------|------------|-------|------------|---------------|-------|-------|
| Dictionary<TKey, TValue>	           | 哈希表	       |无序	| 不可重复	      |不可更改	|O(1)	|O(1)| 
| ConcurrentDictionary<TKey, TValue>	 | 分段锁 + 哈希表	 | 无序	| 不可重复	      | 不可更改	 | O(1)  |	O(1)|
|SortedDictionary<TKey, TValue>	|红黑树	|有序	|不可重复	|不可更改	|O(log n)	|O(log n)|


## tips
使用数组来做哈希的题目，是因为题目都限制了数值的大小。

如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

使用set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

## 做题技巧
1. 字符串是字母，只有二十六个英文字母，所以我们完全可以使用数组作为哈希表，节省空间，不需要维护红黑数和哈希表
2. 想要用什么作为哈希表的键，字符串可以是字符串本身、字符串单个字母进行计数、数字
3. 想要什么作为哈希表的值，可以是集合，下标，计数值和相加值等等
4. Enumerable.SequenceEqual(scount, pcount) C# 中对于Enumberable容器内容的一一比较
5. 数组的交集 
* 方法一：直接用set解决  
* 方法二：通过构造一个较短的哈希表去和另一个集合作对比，得到结果
* 排序加双指针，逐次往后
6. 哈希表有的不需要开始就创建，一般互补的东西在可以在第一次加入哈希表，在第二次就可以查找出来。


