## 什么是动态规划

如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。

## 解题步骤

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 动态规划如何debug

找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！

做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。

## 多重背包

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间
总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的， 为什么和01背包像呢？

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

如果物品数量很多的话，C++中，这种操作十分费时，主要消耗在vector的动态底层扩容上。（其实这里也可以优化，先把
所有物品数量都计算好，一起申请vector的空间。

这里也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。

## 买卖股票

### 买卖一次

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

方法：

* dp[i][0] 表示第i天持有股票所得现金。
* dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

* 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
* **第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
  那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);**

如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来

* 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
* 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]
  同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);

### 多次买卖

你可以尽可能地完成更多的交易（多次买卖一支股票），：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

和上面唯一不同地方是 **多次买卖，买入股票的时候会有之前买卖的利润，所以之前的基础上操作的**

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

* 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
* **第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]**
  不持有股票的状态就可以买入股票，不顾之前有没有买或者买了多次。

### 最多两笔交易
最多可以完成 两笔 交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

一天一共就有五个状态，

* 没有操作 （其实我们也可以不设置这个状态）
* 第一次持有股票
* 第一次不持有股票
* 第二次持有股票
* 第二次不持有股票

因为是有限次的状态，所以通过数组记录每个状态。从第一次交易就和上面交易一次一样，交易第二次就是在第一次的基础上进行操作。

dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

达到dp[i][1]状态，有两个具体操作：

* 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]  或者 不设置没有操纵这个状态的话 直接 dp[i][1] = - prices[i]
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

第二次买入依赖的是第一天卖出时的状态：

dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);

> 初始化： 第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。dp[0][3] = -prices[0];

### k笔交易
最多可以完成 k 笔交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

* 0 表示不操作
* 1 第一次买入
* 2 第一次卖出
* 3 第二次买入
* 4 第二次卖出
* .....

偶数就是卖出，奇数就是买入。

K笔交易 ——> 2*k种状态，如果算上刚开始没操作的状态就是2 * k + 1种状态

其余和上述一样，用一个循环遍历每一天的两种状态就行。

当然有的解法是定义一个三维数组dp[i][j][k]，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。

```c++
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}

for(int j = 1; j < 2 * k + 1; j++){
    //奇數天購買
    if(j % 2 == 1)
        dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);
    //偶數天賣出
    else
        dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]);
}
```

### 含冷冻期的买卖

满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

不同： 在之前的状态上多了一个冷冻期的状态。

* 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
* 不持有股票状态，这里就有两种卖出股票状态
  * 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  * 状态三：今天卖出股票
* 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

把中间两种状态就看做不持有股票状态也可以。

* 达到买入股票状态（状态一）即：dp[i][0]：
* 达到保持卖出股票状态（状态二）即：dp[i][1]：
* 达到今天就卖出股票状态（状态三），即：dp[i][2]
* 达到冷冻期状态（状态四），即：dp[i][3]

```c++
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```
最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。

### 含手续费交易
可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

和多次交易一样，就是需要确定在买入股票的时候支付手续费，还是卖出股票的时候支付手续费。

###  优化：

1. 二维数组优化，看后一天的状态依赖前面哪几天的状态，滚动数组
    ```
   dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
   ```

2. 一维数组优化，只保留当天的状态,或者直接通过变量进行保存
   ```
   // 记录一次交易，一次交易有买入卖出两种状态
    // 0代表持有，1代表卖出
   int[] dp = new int[2];
    
   ```
